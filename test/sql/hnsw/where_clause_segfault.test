# name: test/sql/hnsw/where_clause_segfault.test
# description: If a where clause is present the code segfaults
# group: [hnsw]

require vss

# First try the failing case

statement ok
CREATE TABLE my_vector_table (id INTEGER, vec FLOAT[3]);

statement ok
INSERT INTO my_vector_table (id, vec)
SELECT id, array_value(a, b, c)
FROM range(1, 10) t1(id),
     range(1, 10) t2(a),
     range(1, 10) t3(b),
     range(1, 10) t4(c);

statement ok
CREATE INDEX my_hnsw_index ON my_vector_table USING hnsw (vec);

query I
SELECT array_distance(vec, [1, 2, 3]::FLOAT[3]) < 1.0
FROM my_vector_table
WHERE id > 0
ORDER BY array_distance(vec, [1, 2, 3]::FLOAT[3])
LIMIT 3;
----
1
1
1

# Make sure the plan is not falling back to a sequential scan. Maybe that is not even possible in that case. I think it is possible only if I first materialize the distances (maybe???)

query II
EXPLAIN ANALYZE SELECT *
FROM my_vector_table
WHERE id > 0
ORDER BY array_distance(vec, [1, 2, 3]::FLOAT[3])
LIMIT 3;
----
analyzed_plan	<REGEX>:.*HNSW Index:.*my_hnsw_index.*


query I
SELECT array_distance(vec, [1, 2, 3]::FLOAT[3]) < 1.0
FROM my_vector_table
WHERE id > 3
ORDER BY array_distance(vec, [1, 2, 3]::FLOAT[3])
LIMIT 3;
----
1
1
1


# Change the ranges. That was working before the changes, it should work now as well

statement ok
CREATE TABLE my_vector_table2 (id INTEGER, vec FLOAT[3]);

statement ok
INSERT INTO my_vector_table2 (id, vec)
SELECT id, array_value(a, b, c)
FROM range(0, 10) t1(id),
     range(0, 10) t2(a),
     range(0, 10) t3(b),
     range(0, 10) t4(c);

statement ok
CREATE INDEX my_hnsw_index2 ON my_vector_table2 USING hnsw (vec);

query I
SELECT array_distance(vec, [1, 2, 3]::FLOAT[3]) < 1.0
FROM my_vector_table2
WHERE id > 0
ORDER BY array_distance(vec, [1, 2, 3]::FLOAT[3])
LIMIT 3;
----
1
1
1

query I
SELECT array_distance(vec, [1, 2, 3]::FLOAT[3]) < 1.0
FROM my_vector_table2
WHERE id > 3
ORDER BY array_distance(vec, [1, 2, 3]::FLOAT[3])
LIMIT 3;
----
1
1
1
